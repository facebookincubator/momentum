# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

import subprocess
from pathlib import Path

import tomlkit
from jinja2 import Environment, FileSystemLoader


# Define the template for the header file
header_template = """/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This file is @{{ generated }} by gen_fwd.py
// Do not edit this file directly, instead update gen_fwd_input.toml and run:
// buck run @arvr/mode/platform010/opt //arvr/libraries/momentum:gen_fwd

#pragma once
{% for header in headers %}
#include {{ header }}
{% endfor %}
namespace {{ namespace }} {
{% macro smart_pointers(name, template_suffix='') %}
using {{name}}{{template_suffix}}_p = ::std::shared_ptr<{{name}}{{template_suffix}}>;
using {{name}}{{template_suffix}}_u = ::std::unique_ptr<{{name}}{{template_suffix}}>;
using {{name}}{{template_suffix}}_w = ::std::weak_ptr<{{name}}{{template_suffix}}>;
using {{name}}{{template_suffix}}_const_p = ::std::shared_ptr<const {{name}}{{template_suffix}}>;
using {{name}}{{template_suffix}}_const_u = ::std::unique_ptr<const {{name}}{{template_suffix}}>;
using {{name}}{{template_suffix}}_const_w = ::std::weak_ptr<const {{name}}{{template_suffix}}>;
{% endmacro %}
{% for struct_name in structs %}
struct {{ struct_name }};
{{ smart_pointers(struct_name) }}
{% endfor %}
{% for struct_name in template_structs %}
template <typename T>
struct {{ struct_name }}T;
using {{ struct_name }} = {{ struct_name }}T<float>;
using {{ struct_name }}d = {{ struct_name }}T<double>;
{{ smart_pointers(struct_name) }}
{{ smart_pointers(struct_name, 'd') }}
{% endfor %}
{% for class_name in classes %}
class {{ class_name }};
{{ smart_pointers(class_name) }}
{% endfor %}
{% for class_name in template_classes %}
template <typename T>
class {{ class_name }}T;
using {{ class_name }} = {{ class_name }}T<float>;
using {{ class_name }}d = {{ class_name }}T<double>;
{{ smart_pointers(class_name) }}
{{ smart_pointers(class_name, 'd') }}
{% endfor %}
} // namespace {{ namespace }}

"""


def main():
    try:
        root_dir = Path(__file__).resolve().parent
        uber_graph_path = root_dir / "gen_fwd_input.toml"

        # Load data from TOML file
        with open(uber_graph_path, "r") as file:
            data = tomlkit.parse(file.read())

        # Setup Jinja2 environment
        env = Environment(loader=FileSystemLoader("."))
        template = env.from_string(header_template)

        # Iterate over each fwd in the TOML data
        for module in data["fwd"]:
            subdirectory = root_dir / module["subdirectory"]

            namespace = module.get("namespace", "momentum")
            headers = module.get("headers", []) + ["<memory>"]
            structs = module.get("structs", [])
            template_structs = module.get("template_structs", [])
            classes = module.get("classes", [])
            template_classes = module.get("template_classes", [])

            # Render the template with data from the module
            header_content = template.render(
                generated="generated",
                namespace=namespace,
                headers=headers,
                structs=structs,
                template_structs=template_structs,
                classes=classes,
                template_classes=template_classes,
            )

            # Ensure the subdirectory exists
            subdirectory.mkdir(parents=True, exist_ok=True)

            # Write the output to a header file in the specified subdirectory
            output_path = subdirectory / "fwd.h"
            with open(output_path, "w") as file:
                file.write(header_content)
            subprocess.run(["clang-format", "-i", output_path])
            print(f"Header file '{output_path}' has been generated.")

    except Exception as e:
        import sys

        print(f"An error occurred: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
