/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This file is @generated by gen_fwd.py
// Do not edit this file directly, instead update gen_fwd_input.toml and run:
// buck run @arvr/mode/platform010/opt //arvr/libraries/momentum:gen_fwd

#pragma once

#include <memory>

namespace momentum {

template <typename T>
struct MeshT;
using Mesh = MeshT<float>;
using Meshd = MeshT<double>;

using Mesh_p = ::std::shared_ptr<Mesh>;
using Mesh_u = ::std::unique_ptr<Mesh>;
using Mesh_w = ::std::weak_ptr<Mesh>;
using Mesh_const_p = ::std::shared_ptr<const Mesh>;
using Mesh_const_u = ::std::unique_ptr<const Mesh>;
using Mesh_const_w = ::std::weak_ptr<const Mesh>;

using Meshd_p = ::std::shared_ptr<Meshd>;
using Meshd_u = ::std::unique_ptr<Meshd>;
using Meshd_w = ::std::weak_ptr<Meshd>;
using Meshd_const_p = ::std::shared_ptr<const Meshd>;
using Meshd_const_u = ::std::unique_ptr<const Meshd>;
using Meshd_const_w = ::std::weak_ptr<const Meshd>;

template <typename T>
struct MppcaT;
using Mppca = MppcaT<float>;
using Mppcad = MppcaT<double>;

using Mppca_p = ::std::shared_ptr<Mppca>;
using Mppca_u = ::std::unique_ptr<Mppca>;
using Mppca_w = ::std::weak_ptr<Mppca>;
using Mppca_const_p = ::std::shared_ptr<const Mppca>;
using Mppca_const_u = ::std::unique_ptr<const Mppca>;
using Mppca_const_w = ::std::weak_ptr<const Mppca>;

using Mppcad_p = ::std::shared_ptr<Mppcad>;
using Mppcad_u = ::std::unique_ptr<Mppcad>;
using Mppcad_w = ::std::weak_ptr<Mppcad>;
using Mppcad_const_p = ::std::shared_ptr<const Mppcad>;
using Mppcad_const_u = ::std::unique_ptr<const Mppcad>;
using Mppcad_const_w = ::std::weak_ptr<const Mppcad>;

template <typename T>
struct TransformT;
using Transform = TransformT<float>;
using Transformd = TransformT<double>;

using Transform_p = ::std::shared_ptr<Transform>;
using Transform_u = ::std::unique_ptr<Transform>;
using Transform_w = ::std::weak_ptr<Transform>;
using Transform_const_p = ::std::shared_ptr<const Transform>;
using Transform_const_u = ::std::unique_ptr<const Transform>;
using Transform_const_w = ::std::weak_ptr<const Transform>;

using Transformd_p = ::std::shared_ptr<Transformd>;
using Transformd_u = ::std::unique_ptr<Transformd>;
using Transformd_w = ::std::weak_ptr<Transformd>;
using Transformd_const_p = ::std::shared_ptr<const Transformd>;
using Transformd_const_u = ::std::unique_ptr<const Transformd>;
using Transformd_const_w = ::std::weak_ptr<const Transformd>;

template <typename T>
class LowRankCovarianceMatrixT;
using LowRankCovarianceMatrix = LowRankCovarianceMatrixT<float>;
using LowRankCovarianceMatrixd = LowRankCovarianceMatrixT<double>;

using LowRankCovarianceMatrix_p = ::std::shared_ptr<LowRankCovarianceMatrix>;
using LowRankCovarianceMatrix_u = ::std::unique_ptr<LowRankCovarianceMatrix>;
using LowRankCovarianceMatrix_w = ::std::weak_ptr<LowRankCovarianceMatrix>;
using LowRankCovarianceMatrix_const_p = ::std::shared_ptr<const LowRankCovarianceMatrix>;
using LowRankCovarianceMatrix_const_u = ::std::unique_ptr<const LowRankCovarianceMatrix>;
using LowRankCovarianceMatrix_const_w = ::std::weak_ptr<const LowRankCovarianceMatrix>;

using LowRankCovarianceMatrixd_p = ::std::shared_ptr<LowRankCovarianceMatrixd>;
using LowRankCovarianceMatrixd_u = ::std::unique_ptr<LowRankCovarianceMatrixd>;
using LowRankCovarianceMatrixd_w = ::std::weak_ptr<LowRankCovarianceMatrixd>;
using LowRankCovarianceMatrixd_const_p = ::std::shared_ptr<const LowRankCovarianceMatrixd>;
using LowRankCovarianceMatrixd_const_u = ::std::unique_ptr<const LowRankCovarianceMatrixd>;
using LowRankCovarianceMatrixd_const_w = ::std::weak_ptr<const LowRankCovarianceMatrixd>;

template <typename T>
class GeneralizedLossT;
using GeneralizedLoss = GeneralizedLossT<float>;
using GeneralizedLossd = GeneralizedLossT<double>;

using GeneralizedLoss_p = ::std::shared_ptr<GeneralizedLoss>;
using GeneralizedLoss_u = ::std::unique_ptr<GeneralizedLoss>;
using GeneralizedLoss_w = ::std::weak_ptr<GeneralizedLoss>;
using GeneralizedLoss_const_p = ::std::shared_ptr<const GeneralizedLoss>;
using GeneralizedLoss_const_u = ::std::unique_ptr<const GeneralizedLoss>;
using GeneralizedLoss_const_w = ::std::weak_ptr<const GeneralizedLoss>;

using GeneralizedLossd_p = ::std::shared_ptr<GeneralizedLossd>;
using GeneralizedLossd_u = ::std::unique_ptr<GeneralizedLossd>;
using GeneralizedLossd_w = ::std::weak_ptr<GeneralizedLossd>;
using GeneralizedLossd_const_p = ::std::shared_ptr<const GeneralizedLossd>;
using GeneralizedLossd_const_u = ::std::unique_ptr<const GeneralizedLossd>;
using GeneralizedLossd_const_w = ::std::weak_ptr<const GeneralizedLossd>;

template <typename T>
class SimdGeneralizedLossT;
using SimdGeneralizedLoss = SimdGeneralizedLossT<float>;
using SimdGeneralizedLossd = SimdGeneralizedLossT<double>;

using SimdGeneralizedLoss_p = ::std::shared_ptr<SimdGeneralizedLoss>;
using SimdGeneralizedLoss_u = ::std::unique_ptr<SimdGeneralizedLoss>;
using SimdGeneralizedLoss_w = ::std::weak_ptr<SimdGeneralizedLoss>;
using SimdGeneralizedLoss_const_p = ::std::shared_ptr<const SimdGeneralizedLoss>;
using SimdGeneralizedLoss_const_u = ::std::unique_ptr<const SimdGeneralizedLoss>;
using SimdGeneralizedLoss_const_w = ::std::weak_ptr<const SimdGeneralizedLoss>;

using SimdGeneralizedLossd_p = ::std::shared_ptr<SimdGeneralizedLossd>;
using SimdGeneralizedLossd_u = ::std::unique_ptr<SimdGeneralizedLossd>;
using SimdGeneralizedLossd_w = ::std::weak_ptr<SimdGeneralizedLossd>;
using SimdGeneralizedLossd_const_p = ::std::shared_ptr<const SimdGeneralizedLossd>;
using SimdGeneralizedLossd_const_u = ::std::unique_ptr<const SimdGeneralizedLossd>;
using SimdGeneralizedLossd_const_w = ::std::weak_ptr<const SimdGeneralizedLossd>;

} // namespace momentum
